#include "SM_Manager.h"
#include "VGW_VodStream.h"
#include "MSI_SMStream.h"
#include "Advertisement.h"
#include "Navigation.h"


#include "DBInterface.h"

//#define TEST_DATA

SM_Manager::SM_Manager()
{
	m_Navigation = NULL;
	m_Advertiser = NULL;
	m_VGWVodPlayer = NULL;
	m_Msi_SMInter = NULL;

	printf("---create Manager\n");
	

	//清理完会话需要将对于数据状态修改
}
SM_Manager::~SM_Manager()
{

	if(m_Navigation)
		delete m_Navigation;

	//释放map set中的资源
}


bool SM_Manager::CleanAllStream() //char * strSeesionId,char * strSerialno
{
	MapStreamStatus::iterator it = m_mapStreamStatus.begin();
	while(it != m_mapStreamStatus.end())
	{
		//清理导航流
		char strSID[128] = "1001";
		char strReSID[128] = "1001";
		char strAuthiName[128] = "cscs";
		char strAuthcode[128] = "123456";
		char strMsg[128] = "";
		int iTaskID = 111;


		StreamStatus* pTmp = it->second;
		char strSeesionID[64] ={0};
		sprintf(strSeesionID,"%d",pTmp->istreamID);

		//先清理移动网关
		if(strcmp(pTmp->strBind_userID, "") != 0)
		{
			m_Msi_SMInter->CleanMSIStream(pTmp->strBind_userID,strSeesionID); //seesionID作为serialno
			usleep(1000*100);
		}
		
		//根据数据类型进行不同模块的清理
		if (strcmp(pTmp->strStreamType, Status_Adver) == 0)
		{
				//char strTaskID[64]={0};
			//	sprintf(strTaskID,"%d",pTmp->iTaskID);
				m_Advertiser->CleanAdverStream(strSeesionID,pTmp->strSwitch_task_id,pTmp->strSerialNo);
				usleep(1000*100);
		}
		else if (strcmp(pTmp->strStreamType, Status_Nav) == 0 || 	strcmp(pTmp->strStreamType, Status_Nav_Home) == 0)
		{
			m_Navigation->CleanNavStream(strSeesionID,strSID,pTmp->strSwitch_task_id,strAuthiName,strAuthcode,pTmp->strSerialNo,strMsg);
			usleep(1000*100);
		}
		else if (strcmp(pTmp->strStreamType, Status_Vod) == 0 )
		{
			m_VGWVodPlayer->CleanVODStream(strSeesionID,pTmp->strSwitch_task_id,strSeesionID);
			usleep(1000*100);
		}
/*		else if (strcmp(pTmp->strStreamType, Status_abnormal) == 0)
		{
			//m_Navigation->CleanNavStream(strSeesionID,strSID,strReSID,strAuthiName,strAuthcode,pTmp->strSerialNo,strMsg);
			//
		}
*/		
		it++;
		
	}

	return true;
}
bool SM_Manager::CleanAllTask()
{

return true;

}
bool SM_Manager::CleanStream(int iStreamID,char *strUserID)
{
//只清理广告导航vod
	MapStreamStatus::iterator it = m_mapStreamStatus.find(iStreamID);
	if(it != m_mapStreamStatus.end())
	{
	
		//首先清理掉上一路
				//清理导航流
		char strSID[128] = "1001";
		char strReSID[128] = "1001";
		char strAuthiName[128] = "cscs";
		char strAuthcode[128] = "123456";
		char strMsg[128] = "";
		int iTaskID = 111;
	
	
		StreamStatus* pTmp = it->second;
		char strSeesionID[64] ={0};
		sprintf(strSeesionID,"%d",pTmp->istreamID);

		if(NULL != strUserID)
			strcpy(strUserID,pTmp->strBind_userID);
		//根据数据类型进行不同模块的清理
		if (strcmp(pTmp->strStreamType, Status_Adver) == 0)
		{
				//char strTaskID[64]={0};
			//	sprintf(strTaskID,"%d",pTmp->iTaskID);
				m_Advertiser->CleanAdverStream(strSeesionID,pTmp->strSwitch_task_id,pTmp->strSerialNo);
		//		usleep(1000*100);
		}
		else if (strcmp(pTmp->strStreamType, Status_Nav) == 0 ||	strcmp(pTmp->strStreamType, Status_Nav_Home) == 0)
		{
			m_Navigation->CleanNavStream(strSeesionID,strSID,pTmp->strSwitch_task_id,strAuthiName,strAuthcode,pTmp->strSerialNo,strMsg);
		//	usleep(1000*100);
		}
		else if (strcmp(pTmp->strStreamType, Status_Vod) == 0 )
		{
			m_VGWVodPlayer->CleanVODStream(strSeesionID,pTmp->strSwitch_task_id,strSeesionID);
		//	usleep(1000*100);
		}
	}


	return true;
}
bool SM_Manager::CleanTask(ModuleType emodelType)
{

return true;

}


//下发导航路数及广告流路数
bool SM_Manager::InAdvanceStream(int iNavNum,int iAdverNum)
{

return true;

}

bool SM_Manager::CheckStreamStatus(ModuleType emodelType)
{
	return true;

}
bool SM_Manager::ResouceRecovery(ModuleType emodelType)
{
	return true;

}
/*	bool CheckVodStream();
bool CheckNavgationStream();
bool VODResouceRecovery();
bool NavResouceRecovery();
*/
//装载流通道分组
bool SM_Manager::LoadStreamResource()
{
	m_mapStreamResource.clear();
#ifndef TEST_DATA
	DBInterfacer::GetInstance()->LoadAllStreamResource(m_mapStreamResource);
#else
		int i =0;
		while(i++<11)
			{
				StreamResource *pTmpStream = new StreamResource;
				pTmpStream->iStreamID = i;
				pTmpStream->iOutPutPort = 50438+i*2;
				pTmpStream->iPidMaping = 123;
				pTmpStream->iProgramNum = 321;
				pTmpStream->iBitRate = 30;
				pTmpStream->iIPQAMNum = i/4+1;
				char strRegNum[32]={0};
				sprintf(strRegNum,"%d",(i-1)/2 + 1);
				memcpy(pTmpStream->strNetRegionNum,strRegNum,2);
				pTmpStream->iFreqPoint = 1234;
				memcpy(pTmpStream->strComment,"222",4);
				char testurl[64] = "www.baidu.com";
				memcpy(pTmpStream->strNav_url,testurl,strlen(testurl)+1);
				pTmpStream->iIs_Need_Key = 1;
				memcpy(pTmpStream->strMobile_url,testurl,strlen(testurl)+1);
				//memcpy(pTmpStream->strSessionID,sqlrow[12],strlen(sqlrow[12]));
				//printf("\n");			
				m_mapStreamResource.insert(MapStreamResource::value_type(pTmpStream->iStreamID, pTmpStream));
			}
#endif
	
	return true;
}

//载入网络分组数据
bool SM_Manager::LoadNetWorkGroup()
{
#ifndef TEST_DATA
	DBInterfacer::GetInstance()->LoadNetWorkGroup(m_mapNetworkGroup);

	//根据分组信息载入分组数据
	MapNetWorkGroup::iterator iter = m_mapNetworkGroup.begin();

	while(iter != m_mapNetworkGroup.end())
	{
			//查找每一个分组的数据，导出vector
			ListStreamResource tmplistGroupStream;

			//tmplistGroupStream.clear();
			printf("get group info %s \n",iter->first);
			DBInterfacer::GetInstance()->LoadOneGroupStreamResource(iter->first,tmplistGroupStream);
			if(tmplistGroupStream.size() > 0)
			{
				m_mapStreamGroup.insert(MapStreamGroup::value_type(iter->first, tmplistGroupStream));
				printf("group %s  no data \n",iter->first);
			}
			++iter;

			//需要关联分组编号与流通道
	}
#else
		int i=0;
	//	while(i++<3)
			{
					i++;
					NetworkGroup *pTmpStream = new NetworkGroup;

					char txt[32]={0};
					sprintf(txt,"%d",i);
				//	memcpy(pTmpStream->strNetRegionNum,txt,strlen(txt));
					strcpy(pTmpStream->strNetRegionNum,txt);
					//memcpy(pTmpStream->strNetRegionName,"aa",2);
					strcpy(pTmpStream->strNetRegionName,"aa");
					pTmpStream->iNavgationStreamNum = 1;
					pTmpStream->iAdvertisementStreamNum = 1;
					//memcpy(pTmpStream->strNetworkComment,"qqq",3);
					strcpy(pTmpStream->strNetworkComment,"qqq");
					m_mapNetworkGroup.insert(MapNetWorkGroup::value_type(pTmpStream->strNetRegionNum, pTmpStream));

					int iStreamID = i*2;
					ListStreamResource tmplistGroupStream;
					tmplistGroupStream.push_back( iStreamID);
					tmplistGroupStream.push_back( iStreamID-1);
					m_mapStreamGroup.insert(MapStreamGroup::value_type(pTmpStream->strNetRegionNum, tmplistGroupStream));
			}
					
#endif
	
	return true;
}


bool SM_Manager::LoadStreamStatus()
{
	m_mapStreamStatus.clear();
#ifndef TEST_DATA
	DBInterfacer::GetInstance()->LoadAllStreamStatus(m_mapStreamStatus);
#else
	{
/*		StreamStatus *pTmpStream = new StreamStatus;
		memset(pTmpStream,0,sizeof(StreamStatus));
		pTmpStream->istreamID = 1;
		memcpy(pTmpStream->strStreamType,Status_Adver,strlen(Status_Adver)+1);
		memcpy(pTmpStream->strBind_userID,"123098",7);
		char tmp[64]="2014-9-7";
		memcpy(pTmpStream->strBind_date,tmp,strlen(tmp)+1);
		memcpy(pTmpStream->strSwitch_task_id,"333221",7);		
		m_mapStreamStatus.insert(MapStreamStatus::value_type(pTmpStream->istreamID, pTmpStream));

		StreamStatus *pTmpStream1 = new StreamStatus;
		memset(pTmpStream1,0,sizeof(StreamStatus));
		pTmpStream1->istreamID = 2;
		memcpy(pTmpStream1->strStreamType,Status_Nav,strlen(Status_Nav)+1);
		memcpy(pTmpStream1->strBind_userID,"123098",7);
		char tmp1[64]="2014-9-7";
		memcpy(pTmpStream1->strBind_date,tmp1,strlen(tmp1)+1);
		memcpy(pTmpStream1->strSwitch_task_id,"3332211",8);		
		m_mapStreamStatus.insert(MapStreamStatus::value_type(pTmpStream1->istreamID, pTmpStream1));


		
		StreamStatus *pTmpStream2 = new StreamStatus;
		memset(pTmpStream2,0,sizeof(StreamStatus));
		pTmpStream2->istreamID = 3;
		memcpy(pTmpStream2->strStreamType,Status_Vod,strlen(Status_Vod)+1);
		memcpy(pTmpStream2->strBind_userID,"123098",7);
		char tmp2[64]="2014-9-7";
		memcpy(pTmpStream2->strBind_date,tmp2,strlen(tmp2)+1);
		memcpy(pTmpStream2->strSwitch_task_id,"33322111",9);		
		m_mapStreamStatus.insert(MapStreamStatus::value_type(pTmpStream2->istreamID, pTmpStream2));
*/	}

#endif
	printf("---map size =%d \n",m_mapStreamStatus.size());
		//echo data;
#ifdef TEST_DATA		
	MapStreamStatus::iterator it = m_mapStreamStatus.begin();
	while(it != m_mapStreamStatus.end())
	{
		StreamStatus *ptmp = it->second;
		/*
		int istreamID;
		char strStreamType[32];
		char strStatus_date[128];
		char strBind_userID[128];
		char strBind_date[128];
		char strSwitch_task_id[128];
		char strSessionID[512];
		char strSerialNo[512];

		*/
		printf("%d, %s,%s,%s,%s,%s,%s,%s, \n ",ptmp->istreamID,ptmp->strStreamType,
				ptmp->strStatus_date,ptmp->strBind_userID,ptmp->strBind_date,
				ptmp->strSwitch_task_id,ptmp->strSessionID,ptmp->strSerialNo);
		++it;
	}
#endif	
	return true;
}

bool SM_Manager::LoadIPQAMInfo()
{
	m_mapIpqamInfo.clear();
#ifndef TEST_DATA
	DBInterfacer::GetInstance()->LoadALLIPQAMInfo(m_mapIpqamInfo);
#else
	IPQAMInfo *pTmpStream = new IPQAMInfo;
	memset(pTmpStream,0,sizeof(IPQAMInfo));

	char strIP[64] ="192.168.100.106";
	pTmpStream->iIPQAMNum = 1;
	memcpy(pTmpStream->strIpqamName,"name1",6);
	memcpy(pTmpStream->strIpqamIP,strIP,strlen(strIP)+1);
	pTmpStream->iIpqamManagerPort = 10000;
	memcpy(pTmpStream->strIpqamType,"211",3+1);
	memcpy(pTmpStream->strIpqamModel,"A",1+1);
	memcpy(pTmpStream->strIpqamManufacturers,"eqw",3+1);
	memcpy(pTmpStream->strIpqamComment,"442",3+1);
	pTmpStream->iIsSupportR6 = 0;
	m_mapIpqamInfo.insert(MapIPQAMInfo::value_type(pTmpStream->iIPQAMNum, pTmpStream));

	pTmpStream = new IPQAMInfo;
	memset(pTmpStream,0,sizeof(IPQAMInfo));
	//char strIP[64] ="192.168.1.1";
	pTmpStream->iIPQAMNum = 2;
	memcpy(pTmpStream->strIpqamName,"name1",5+1);
	memcpy(pTmpStream->strIpqamIP,strIP,strlen(strIP)+1);
	pTmpStream->iIpqamManagerPort = 11000;
	memcpy(pTmpStream->strIpqamType,"211",3+1);
	memcpy(pTmpStream->strIpqamModel,"A",1+1);
	memcpy(pTmpStream->strIpqamManufacturers,"eqw",3+1);
	memcpy(pTmpStream->strIpqamComment,"442",3+1);
	pTmpStream->iIsSupportR6 = 0;
	m_mapIpqamInfo.insert(MapIPQAMInfo::value_type(pTmpStream->iIPQAMNum, pTmpStream));


#endif

	
	return true;
}


bool SM_Manager::AddOneStream(ModuleType emodelType,int iOldStreamID)
{

	char strnetWork_Reg[128]={0};
	int iNewStreamID = -1;
	bool bInStatus = false;
	char strStreamType[64]={0};
	char TmpTime[64]={0};
	
	if(iOldStreamID > 0)
	{	//补发
		printf("find other stream from stream %d \n",iOldStreamID);
		MapStreamResource::iterator itfid = m_mapStreamResource.find(iOldStreamID);
		if(itfid != m_mapStreamResource.end())
		{
			StreamResource *pTmp = itfid->second;
			//从分组表中找到
			printf("find group %s streamgroup size=%d\n",pTmp->strNetRegionNum,m_mapStreamGroup.size());
			//MapStreamGroup::iterator itstremfind  = m_mapStreamGroup.find(pTmp->strNetRegionNum);
			MapStreamGroup::iterator itstremfind  = m_mapStreamGroup.begin();

			while(itstremfind != m_mapStreamGroup.end())
			{
				if(strcmp(itstremfind->first,pTmp->strNetRegionNum) == 0)
				{
					printf("find same group \n");
					ListStreamResource listTmp = itstremfind->second;
					ListStreamResource::iterator iterList = listTmp.begin();
					char TmpTime[64]={0};
					while(iterList != listTmp.end())
					{
						int iStreamID = *iterList;
						MapStreamStatus::iterator itFind = m_mapStreamStatus.find(iStreamID);
						if(itFind != m_mapStreamStatus.end())
						{
							StreamStatus *ptmpstat = itFind->second;
							if(strcmp(ptmpstat->strStreamType,Status_Adver)==0 && emodelType == Navigation)
							{
								//广告流可使用的流
								printf("---find one stream adver %d \n",iNewStreamID);
								iNewStreamID = iStreamID;
								bInStatus = true;
								strcpy(strStreamType,ptmpstat->strStreamType);
								break;
							}
							else// if(strcmp(ptmpstat->strStreamType,Status_Nav)!=0 && (strcmp(ptmpstat->strBind_userID,"NULL")==0 ||
								//	strcmp(ptmpstat->strBind_userID,"")==0 ))
							{
								//最远使用的流
								if(strcmp(TmpTime,ptmpstat->strStatus_date) < 0)
								{
									strcpy(TmpTime,ptmpstat->strStatus_date);
									iNewStreamID = iStreamID;
									strcpy(strStreamType,ptmpstat->strStreamType);
								}		

							}
						}	

						++iterList;
					}
					
				}
				++itstremfind;
			}

		}

	}

	if(iNewStreamID == -1)
	{
		printf("Add one stream failed emodelType=%d\n",emodelType);
		return false;
	}
	printf("---the last status Time = %s \n",TmpTime);
	switch(emodelType)
	{
		case Advertisement:
		{
			if(bInStatus)
			{
				MapStreamStatus::iterator it = m_mapStreamStatus.find(iNewStreamID);
				if(it != m_mapStreamStatus.end())
				{
					StreamStatus* ptmp = it->second;
					
								//下发
					char strSeesionID[64] = {0};
					sprintf(strSeesionID,"%d",ptmp->istreamID);
					printf("Add one adv stream in status \n");
					//m_Advertiser->StartOneStream("1","udp://239.1.1.1:12000","udp://192.168.100.106:50442","e123214");
				
					
				}
			}
			else
			{

				//找到对应流信息
				MapStreamResource::iterator iterStream = m_mapStreamResource.find(iNewStreamID);
				if(iterStream != m_mapStreamResource.end())
				{
					StreamResource *pStream = iterStream->second;
					//调用下发一路导航流
					char strSeesionID[64] ={0};
					sprintf(strSeesionID,"%d",pStream->iStreamID);
					char strSID[64] ="1001";
					char strReSID[64] ="2000"; //operid
					char strSIP[64] ="192.168.30.160";
					char strSPort[32]="12000";
					char strAreaID[32] ="3301";
					
					int iIPQAMnum = pStream->iIPQAMNum;
					printf("---ipqam info num=%d \n",iIPQAMnum);
					MapIPQAMInfo::iterator itIpqam = m_mapIpqamInfo.find(iIPQAMnum);
					if(itIpqam != m_mapIpqamInfo.end())
					{
						IPQAMInfo *pIpqam = itIpqam->second;
				
						char strOutPort[64]={0};
						sprintf(strOutPort,"%d",pStream->iOutPutPort);
						char strMsg[32]="";
						//导航流的url是否需拼接
						m_Navigation->StartOneStream(strSeesionID,strSID,strReSID,pStream->strNav_url,pIpqam->strIpqamIP,
									strOutPort,strSIP,strSPort,strAreaID,strSeesionID,strMsg);
						//listTmp.erase(iterList);
						printf("---start one nav stream %s,group id=%s,ipqamnum=%d\n",strSeesionID,
								pStream->strNetRegionNum,pStream->iIPQAMNum);
					}
					
						
				}

			}
		}
		break;
		case Navigation:
		{
			//if(bInStatus)
			{
				MapStreamStatus::iterator it = m_mapStreamStatus.find(iNewStreamID);
				if(it != m_mapStreamStatus.end())
				{

					//首先清理掉上一路
							//清理导航流
					char strSID[128] = "1001";
					char strReSID[128] = "1001";
					char strAuthiName[128] = "cscs";
					char strAuthcode[128] = "123456";
					char strMsg[128] = "";
					int iTaskID = 111;


					StreamStatus* pTmp = it->second;
					char strSeesionID[64] ={0};
					sprintf(strSeesionID,"%d",pTmp->istreamID);

									//将需要转发的导航流存在vector
					m_vecNewNav.insert(iNewStreamID);
					printf("-----set size=%d \n",m_vecNewNav.size());
					//先清理移动网关
					if(strcmp(pTmp->strBind_userID, "") != 0)
					{
						m_Msi_SMInter->CleanMSIStream(pTmp->strBind_userID,strSeesionID); //seesionID作为serialno
					//	usleep(1000*100);
					}
					
					//根据数据类型进行不同模块的清理
					if (strcmp(pTmp->strStreamType, Status_Adver) == 0)
					{
							//char strTaskID[64]={0};
						//	sprintf(strTaskID,"%d",pTmp->iTaskID);
							m_Advertiser->CleanAdverStream(strSeesionID,pTmp->strSwitch_task_id,pTmp->strSerialNo);
					//		usleep(1000*100);
					}
					else if (strcmp(pTmp->strStreamType, Status_Nav) == 0 || 	strcmp(pTmp->strStreamType, Status_Nav_Home) == 0)
					{
						m_Navigation->CleanNavStream(strSeesionID,strSID,pTmp->strSwitch_task_id,strAuthiName,strAuthcode,pTmp->strSerialNo,strMsg);
					//	usleep(1000*100);
					}
					else if (strcmp(pTmp->strStreamType, Status_Vod) == 0 )
					{
						m_VGWVodPlayer->CleanVODStream(strSeesionID,pTmp->strSwitch_task_id,strSeesionID);
					//	usleep(1000*100);
					}
				}
				//usleep(1000*2000);

					//创建一路导航流
/*				MapStreamResource::iterator iterStream = m_mapStreamResource.find(iNewStreamID);
				if(iterStream != m_mapStreamResource.end())
				{
					StreamResource *pStream = iterStream->second;
					//调用下发一路导航流
					char strSeesionID[64] ={0};
					sprintf(strSeesionID,"%d",pStream->iStreamID);
					char strSID[64] ="1001";
					char strReSID[64] ="2000"; //operid
					char strSIP[64] ="192.168.30.160";
					char strSPort[32]="12000";
					char strAreaID[32] ="3301";
					
					int iIPQAMnum = pStream->iIPQAMNum;
					printf("---ipqam info num=%d \n",iIPQAMnum);
					MapIPQAMInfo::iterator itIpqam = m_mapIpqamInfo.find(iIPQAMnum);
					if(itIpqam != m_mapIpqamInfo.end())
					{
						IPQAMInfo *pIpqam = itIpqam->second;

						char strOutPort[64]={0};
						sprintf(strOutPort,"%d",pStream->iOutPutPort);
						char strMsg[32]="";
						//导航流的url是否需拼接
						m_Navigation->StartOneStream(strSeesionID,strSID,strReSID,pStream->strNav_url,pIpqam->strIpqamIP,
									strOutPort,strSIP,strSPort,strAreaID,strSeesionID,strMsg);
						//listTmp.erase(iterList);
						printf("---start one nav stream %s,group id=%s,ipqamnum=%d\n",strSeesionID,
								pStream->strNetRegionNum,pStream->iIPQAMNum);
					}
					
					
				}
	*/			
			}
				
			break;
		}
		break;
		default:
		break;
	}
	
	return true;
}

int SM_Manager::AddOneVodStream(int iStreamID,char* strUrl,int iFd,char* strSerilno)
{
	char strUserID[128]={0};
	//先释放资源
	CleanStream(iStreamID,strUserID);
	usleep(1000*1500);
	printf("----get userid %s \n",strUserID);


	MapStreamResource::iterator it = m_mapStreamResource.find(iStreamID);
	if(it != m_mapStreamResource.end())
	{
		StreamResource* pTmp = it->second;

		Stream *ptmpRequest = new Stream;

		ptmpRequest->m_clientSocket = iFd;
		//cJSON *pRet_root;
		ptmpRequest->pRet_root = cJSON_CreateObject();
		ptmpRequest->Requst_Json_str(2,"serialno",strSerilno);
		m_VGWVodPlayer->m_mapVod_player.insert(MapVodPlay::value_type(iStreamID,ptmpRequest));
		
		if(m_VGWVodPlayer->StartOneStream(iStreamID,strUrl,pTmp->strNetRegionNum,strUserID))
		{
			//成功点播
			return 0;
		}
		else
		{
			return -1;
		}
	}
}


bool SM_Manager::GetTaskStatus()
{
	return true;

}

bool SM_Manager::InitStream()
{
	m_Navigation = new Navigation_Stream(this);
	m_Advertiser = new Advertisement_Stream(this);
	m_VGWVodPlayer = new VGW_Vod_Stream(this);
	m_Msi_SMInter = new MSI_SM_Stream(this);

	//先开启清理模式
	//首先导入状态表数据非空闲状态
	if(LoadStreamStatus())
	{
		//开始清理
		CleanAllStream();
		//模块回复处理由各个对象处理
		usleep(1000*500);
	}
	else
		printf("---load clean data error \n");

	
	//按组进行初始化
	//先导入资源表
	LoadStreamResource();
	LoadIPQAMInfo();
	printf("---begin init network group\n");
	LoadNetWorkGroup();
	printf("---load success \n");

#ifdef TEST_DATA
	//sleep(30);
	MapStreamStatus::iterator iter = m_mapStreamStatus.begin();
	FILE *fp = fopen("result.log","wb+");
	while(iter != m_mapStreamStatus.end())
	{
		StreamStatus *ptm = iter->second;
		/*
			int istreamID;
	char strStreamType[32];
	char strStatus_date[128];
	char strBind_userID[128];
	char strBind_date[128];
	char strSwitch_task_id[128];
	char strSessionID[512];
	char strSerialNo[512];
	*/
		fprintf(fp,"%d \t %s \t %s \t %s \t %s \t %s \n",ptm->istreamID,
			ptm->strStreamType,ptm->strStatus_date,ptm->strBind_userID,ptm->strBind_date,
			ptm->strSwitch_task_id);
		fflush(fp);
		++iter;
	}

	MapStreamResource::iterator itResource = m_mapStreamResource.begin();
	while(itResource != m_mapStreamResource.end())
	{
		StreamResource *ptmp = itResource->second;
		fprintf(fp,"%d \t %d \t %s \n",ptmp->iStreamID,ptmp->iIPQAMNum,
				ptmp->strNetRegionNum);
		fflush(fp);

		++itResource;
	}
	MapStreamGroup::iterator ittmp = m_mapStreamGroup.begin();
	while(ittmp != m_mapStreamGroup.end())
	{
		ListStreamResource listTmp1 = ittmp->second;
		ListStreamResource::iterator iterList1 = listTmp1.begin();
		while(iterList1 != listTmp1.end())
		{
			printf("---group %s stream id =%d \n ",ittmp->first,*iterList1);
			++iterList1;
			
		}
		++ittmp;
	}
	
#endif
	
	
	//总共分组m_mapNetworkGroup中
	//关联流信息组在m_mapStreamGroup中
	printf("StreamResoure size=%d ,status size=%d ,group size=%d ,streamGroup size=%d \n",
		m_mapStreamResource.size(),m_mapStreamStatus.size(),m_mapNetworkGroup.size(),m_mapStreamGroup.size());

	MapStreamGroup::iterator iterGroup = m_mapStreamGroup.begin();
	bool bHasCreateStream = false;
	while(iterGroup != m_mapStreamGroup.end() )
	{
		int iNavtaionNum = 0;
		int iAdverNum = 0;;
		MapNetWorkGroup::iterator itwork = m_mapNetworkGroup.find(iterGroup->first);
		if(itwork != m_mapNetworkGroup.end())
		{
			NetworkGroup *ptmp = itwork->second;
			iNavtaionNum = ptmp->iNavgationStreamNum;
			iAdverNum = ptmp->iAdvertisementStreamNum;

			//ListStreamResource *plistTmp = &(iterGroup->second);
			ListStreamResource listTmp = iterGroup->second;
			

			int iGroupSize = listTmp.size();
			iNavtaionNum =  (iNavtaionNum <= iGroupSize) ?  iNavtaionNum : iGroupSize;

			printf("----begin group %s -- add Nav num=%d listsize=%d\n",ptmp->strNetRegionNum,
					iNavtaionNum,iGroupSize);
			ListStreamResource::iterator iterList = listTmp.begin();
			//开始下发流
			while(iNavtaionNum-- > 0 && iterList != listTmp.end())
			{

				//导航流
				int iStreamID = *iterList;
				printf("----streamid=%d ready\n",iStreamID);
				//找到对应流信息
				MapStreamResource::iterator iterStream = m_mapStreamResource.find(iStreamID);
				if(iterStream != m_mapStreamResource.end())
				{
					StreamResource *pStream = iterStream->second;
					//调用下发一路导航流
					char strSeesionID[64] ={0};
					sprintf(strSeesionID,"%d",pStream->iStreamID);
					char strSID[64] ="1001";
					char strReSID[64] ="2000"; //operid
					char strSIP[64] ="192.168.30.160";
					char strSPort[32]="12000";
					char strAreaID[32] ="3301";
					
					int iIPQAMnum = pStream->iIPQAMNum;
					printf("---ipqam info num=%d \n",iIPQAMnum);
					MapIPQAMInfo::iterator itIpqam = m_mapIpqamInfo.find(iIPQAMnum);
					if(itIpqam != m_mapIpqamInfo.end())
					{
						IPQAMInfo *pIpqam = itIpqam->second;

						char strOutPort[64]={0};
						sprintf(strOutPort,"%d",pStream->iOutPutPort);
						char strMsg[32]="";
						//导航流的url是否需拼接
						m_Navigation->StartOneStream(strSeesionID,strSID,strReSID,pStream->strNav_url,pIpqam->strIpqamIP,
									strOutPort,strSIP,strSPort,strAreaID,strSeesionID,strMsg);
						listTmp.erase(iterList);
						printf("---start one nav stream %s,group id=%s,ipqamnum=%d\n",strSeesionID,
								pStream->strNetRegionNum,pStream->iIPQAMNum);
						usleep(1000*100);
					}
					
						
				}
				//++iterList;
				iterList = listTmp.begin();
			}

			iGroupSize = listTmp.size();
			iAdverNum =	iAdverNum <= iGroupSize ?  iAdverNum : iGroupSize;

			iterList = listTmp.begin();
			printf("----begin group %s adv %d groupsize=%d \n",ptmp->strNetRegionNum,
					iAdverNum,iGroupSize);
			while(iAdverNum-- > 0 && iterList != listTmp.end())
			{
				//导航流
				int iStreamID = *iterList;
				//找到对应流信息
				MapStreamResource::iterator iterStream = m_mapStreamResource.find(iStreamID);
				if(iterStream != m_mapStreamResource.end())
				{
					StreamResource *pStream = iterStream->second;
					//调用下发一路导航流
					char strSeesionID[64] ={0};
					sprintf(strSeesionID,"%d",pStream->iStreamID);
					
					int iIPQAMnum = pStream->iIPQAMNum;
					MapIPQAMInfo::iterator itIpqam = m_mapIpqamInfo.find(iIPQAMnum);
					if(itIpqam != m_mapIpqamInfo.end())
					{
						IPQAMInfo *pIpqam = itIpqam->second;

						char strOutputUrl[128]={0};
						sprintf(strOutputUrl,"udp://%s:%d",pIpqam->strIpqamIP,pStream->iOutPutPort);

						char strInputUrl[128] ={0};
						int idex = pStream->iStreamID % (iMulitNum-1);
						strcpy(strInputUrl,strVLCMulitURL[idex]);
						char strMsg[32]="";
						m_Advertiser->StartOneStream(strSeesionID,strInputUrl,strOutputUrl,strSeesionID);
						listTmp.erase(iterList);
						printf("---start one adv stream %s,group id=%s,ipqamnum=%d\n",strSeesionID,
								pStream->strNetRegionNum,pStream->iIPQAMNum);
						usleep(1000*100);
					}
					
						
				}
				//++iterList;
				iterList = listTmp.begin();
			}
			iterGroup++;
			//reload group
		//	char strGroupID[128]={0};
		//	strcpy(strGroupID,iterGroup->first);
		//	m_mapStreamGroup.erase(iterGroup++);
		//	m_mapStreamGroup.insert(MapStreamGroup::value_type(strGroupID, listTmp));
			
		}
		else
			++iterGroup;

	}
	return true;
}

int SM_Manager::Bind_OneStream(int iStreamid,char *strUserID,char* strToken)
{
	printf("---begin bind onestream\n");
	//主要是更新数据库，补发导航流
	//找到对应数据
 	MapStreamStatus::iterator itfind = m_mapStreamStatus.find(iStreamid);
	if(itfind != m_mapStreamStatus.end())
	{
		
		//
		time_t timep; 
		time (&timep); 
		struct tm* tmpTime = gmtime(&timep);
		char nowTime[128]={0};
		// -%d-%d ,tmpTime->tm_hour,tmpTime->tm_min
		// 月日时分秒
		sprintf(nowTime,"%d-%d-%d-%d:%d:%d",tmpTime->tm_year+1900,tmpTime->tm_mon+1,tmpTime->tm_mday,
			tmpTime->tm_hour,tmpTime->tm_min,tmpTime->tm_sec); //bind time
		printf("--time =%s \n",nowTime);


		StreamStatus *pTmp = itfind->second;
		strcpy(pTmp->strBind_date,nowTime);
		strcpy(pTmp->strBind_userID,strUserID);
		//strcpy(pTmp->strSwitch_task_id,strToken);

		//状态时间修改一次则更新
		strcpy(pTmp->strStatus_date,nowTime);

		DBInterfacer::GetInstance()->update_table(1,pTmp);

		printf("bind one stream success\n",iStreamid);
		//成功之后需要补发一路导航流
		//首先寻找可用的
	//	AddOneStream(Navigation);
	}
	else
	{
		//不存在的流返回异常
		return -1;
	}


	return 0;
}

bool SM_Manager::AddStream2GroupInfo(int iStreamID,int iType)
{
	if(1==iType)
	{
		MapStreamResource::iterator itfid = m_mapStreamResource.find(iStreamID);
		if(itfid != m_mapStreamResource.end())
		{
			StreamResource *pTmp = itfid->second;
			//从分组表中找到
			MapStreamGroup::iterator itstremfind  = m_mapStreamGroup.find(pTmp->strNetRegionNum);
			if(itstremfind != m_mapStreamGroup.end())
			{
				ListStreamResource listTmp = itstremfind->second;
				//ListStreamResource::iterator iterList = listTmp.begin();
				listTmp.push_back( iStreamID);
			}

		}
	}	
	else if(0==iType)
	{
		MapStreamResource::iterator itfid = m_mapStreamResource.find(iStreamID);
		if(itfid != m_mapStreamResource.end())
		{
			StreamResource *pTmp = itfid->second;
			//从分组表中找到
			MapStreamGroup::iterator itstremfind  = m_mapStreamGroup.find(pTmp->strNetRegionNum);
			if(itstremfind != m_mapStreamGroup.end())
			{
				ListStreamResource listTmp = itstremfind->second;
				ListStreamResource::iterator iterList = listTmp.begin();
				while(iterList != listTmp.end())
				{
					if(*iterList == iStreamID)
					{
						listTmp.erase(iterList);
						break;
					}
					++iterList;
				}
				//listTmp.push_back( iStreamID);
			}

		}
		
	}
	return true;
}

int SM_Manager::AddOneNavStream(int iStreamID)
{
	int ret = -1;
	printf("------add one nav \n");
		//创建一路导航流
	MapStreamResource::iterator iterStream = m_mapStreamResource.find(iStreamID);
	if(iterStream != m_mapStreamResource.end())
	{
		StreamResource *pStream = iterStream->second;
		//调用下发一路导航流
		char strSeesionID[64] ={0};
		sprintf(strSeesionID,"%d",pStream->iStreamID);
		char strSID[64] ="1001";
		char strReSID[64] ="2000"; //operid
		char strSIP[64] ="192.168.30.160";
		char strSPort[32]="12000";
		char strAreaID[32] ="3301";
		
		int iIPQAMnum = pStream->iIPQAMNum;
		printf("---ipqam info num=%d \n",iIPQAMnum);
		MapIPQAMInfo::iterator itIpqam = m_mapIpqamInfo.find(iIPQAMnum);
		if(itIpqam != m_mapIpqamInfo.end())
		{
			IPQAMInfo *pIpqam = itIpqam->second;

			char strOutPort[64]={0};
			sprintf(strOutPort,"%d",pStream->iOutPutPort);
			char strMsg[32]="";
			//导航流的url是否需拼接
			m_Navigation->StartOneStream(strSeesionID,strSID,strReSID,pStream->strNav_url,pIpqam->strIpqamIP,
						strOutPort,strSIP,strSPort,strAreaID,strSeesionID,strMsg);
			//listTmp.erase(iterList);
			printf("---start one nav stream %s,group id=%s,ipqamnum=%d\n",strSeesionID,
					pStream->strNetRegionNum,pStream->iIPQAMNum);
		}
		ret = 0;
		
	}

	return ret;
}

bool SM_Manager::VodStreamOver(int iStreamID)
{
	//开启一路新的导航流
	//先清理
	CleanStream(iStreamID);
	usleep(1000*100);
	
	AddOneNavStream(iStreamID);
	return true;
}




